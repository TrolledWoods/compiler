use crate::string_pile::TinyString;
use chashmap::{CHashMap, ReadGuard, WriteGuard};
use std::num::NonZeroU32;
use std::sync::atomic::{AtomicU32, Ordering};

#[derive(Clone, Copy, Hash, PartialEq, Eq, Debug)]
pub struct NamespaceID(NonZeroU32);

#[derive(Clone, Copy)]
pub enum NamespaceContent<T: Copy> {
    Namespace(NamespaceID),
    Other(T),
}

pub enum LocateMemberFault {
    NoContentWithName(TinyString),
}

pub struct Namespace<T: Copy> {
    name: Option<TinyString>,
    parent: Option<NamespaceID>,
    contents: CHashMap<TinyString, (Publicity, NamespaceContent<T>)>,

    named_exports: CHashMap<TinyString, (Publicity, ExportMode, NamespaceID)>,
    wildcard_exports: Vec<(Publicity, ExportMode, NamespaceID)>,
}

pub struct NamespaceManager<T: Copy> {
    namespace_id_ctr: AtomicU32,
    namespaces: CHashMap<NamespaceID, Namespace<T>>,
}

impl<T: Copy> NamespaceManager<T> {
    pub fn new() -> NamespaceManager<T> {
        NamespaceManager {
            namespace_id_ctr: AtomicU32::new(1),
            namespaces: CHashMap::new(),
        }
    }

    fn allocate_id(&self) -> NamespaceID {
        let id = self.namespace_id_ctr.fetch_add(1, Ordering::SeqCst);

        // Pretty sure that the id won't be the wrong type
        NamespaceID(NonZeroU32::new(id).unwrap())
    }

    pub fn create_root(&self) -> NamespaceID {
        let id = self.allocate_id();

        let namespace = Namespace {
            name: None,
            parent: None,
            contents: CHashMap::new(),
            named_exports: CHashMap::new(),
            wildcard_exports: Vec::new(),
        };

        if self.namespaces.insert(id, namespace).is_some() {
            panic!("allocate_id allocated an id twice");
        }
        id
    }

    pub fn create_named_namespace(
        &self,
        parent_id: NamespaceID,
        name: TinyString,
        publicity: Publicity,
        parent_exports: Option<ExportMode>,
    ) -> NamespaceID {
        let id = self.allocate_id();

        let namespace = Namespace {
            name: Some(name),
            parent: Some(parent_id),
            contents: CHashMap::new(),
            named_exports: CHashMap::new(),
            wildcard_exports: Vec::new(),
        };

        if self.namespaces.insert(id, namespace).is_some() {
            panic!("allocate_id allocated an id twice");
        }

        let mut parent = self.get_namespace_mut(parent_id);
        if let Some(export_mode) = parent_exports {
            parent
                .wildcard_exports
                .push((Publicity::Private, export_mode, id));
        }

        parent
            .contents
            .insert(name, (publicity, NamespaceContent::Namespace(id)));

        id
    }

    pub fn create_anonymous_namespace(
        &self,
        parent_id: NamespaceID,
        parent_exports: Option<ExportMode>,
    ) -> NamespaceID {
        let id = self.allocate_id();

        let namespace = Namespace {
            name: None,
            parent: Some(parent_id),
            contents: CHashMap::new(),
            named_exports: CHashMap::new(),
            wildcard_exports: Vec::new(),
        };

        if self.namespaces.insert(id, namespace).is_some() {
            panic!("allocate_id allocated an id twice");
        }

        if let Some(export_mode) = parent_exports {
            let mut parent = self.get_namespace_mut(parent_id);
            parent
                .wildcard_exports
                .push((Publicity::Private, export_mode, id));
        }

        id
    }

    /// Returns the namespace based on the namespace id.
    /// Watch out, only use NamespaceID:s generated by
    /// this struct, as otherwise this method MIGHT generate
    /// a panic(may also become a slow and annoying thing to debug).
    pub fn get_namespace<'a>(
        &'a self,
        id: NamespaceID,
    ) -> ReadGuard<'a, NamespaceID, Namespace<T>> {
        match self.namespaces.get(&id) {
            Some(n) => n,
            None => unreachable!(
                "Invalid NamespaceID, maybe you mixed\
                    ids between namespace managers?"
            ),
        }
    }

    /// Returns the namespace based on the namespace id.
    /// Watch out, only use NamespaceID:s generated by
    /// this struct, as otherwise this method MIGHT generate
    /// a panic(may also become a slow and annoying thing to debug).
    pub fn get_namespace_mut<'a>(
        &'a self,
        id: NamespaceID,
    ) -> WriteGuard<'a, NamespaceID, Namespace<T>> {
        match self.namespaces.get_mut(&id) {
            Some(n) => n,
            None => unreachable!(
                "Invalid NamespaceID, maybe you mixed\
                    ids between namespace managers?"
            ),
        }
    }

    pub fn search(
        &self,
        src: NamespaceID,
        path: impl Iterator<Item = impl Into<TinyString>>,
    ) -> Option<NamespaceContent<T>> {
        self.search_path_recursive(NamespaceContent::Namespace(src), path)
    }

    fn search_path_recursive(
        &self,
        src: NamespaceContent<T>,
        mut path: impl Iterator<Item = impl Into<TinyString>>,
    ) -> Option<NamespaceContent<T>> {
        match path.next() {
            Some(value) => {
                if let NamespaceContent::Namespace(id) = src {
                    let namespace = self.get_namespace(id);
                    let contents = &namespace.contents;

                    let tiny: TinyString = value.into();
                    let guard = contents.get(&tiny);

                    if let Some(guard) = guard {
                        self.search_path_recursive(guard.1, path)
                    } else {
                        None
                    }
                } else {
                    // There was more path, but this
                    // wasn't a namespace
                    None
                }
            }
            None => Some(src),
        }
    }

    pub fn get_path(&self, id: NamespaceID) -> TinyString {
        let namespace = self.get_namespace(id);

        let name: TinyString = namespace.name.unwrap_or_else(|| "".into());

        match namespace.parent {
            Some(parent_id) => {
                let prefix = self.get_path(parent_id);
                let mut path = prefix.to_string();
                path.push('\\');
                path.push_str(&name.to_string());
                path.into()
            }
            None => name,
        }
    }

    // pub fn locate_member(&self,
    //                      src: NamespaceContent<T>,
    //                      path: Iterator<Item = TinyString>)
    //         -> Result<T, LocateMemberFault> {
    //     match path.next() {
    //         Some(descent) => {
    //             if let NamespaceContent::Namespace(id) = src {
    //                 let namespace = self.get_namespace(&id);
    //             }else {
    //             }
    //         },
    //     }
    // }

    /// Inserts a member into the namespace.
    /// If you need to insert a namespace, there are methods to doing that.
    /// That's because inserting a namespace has more things that may
    /// happen, and we want those things to be convenient.
    pub fn insert_member(
        &self,
        namespace_id: NamespaceID,
        member_name: TinyString,
        member: T,
        publicity: Publicity,
    ) -> bool {
        let namespace = self.get_namespace(namespace_id);

        let old_member = namespace
            .contents
            .insert(member_name, (publicity, NamespaceContent::Other(member)));

        // If there was an old member with this name,
        // we have a name collision!
        old_member.is_some()
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ExportMode {
    All,
    Public,
}

impl ExportMode {
    pub fn can_export(&self, publicity: Publicity) -> bool {
        use ExportMode::*;
        match self {
            All => true,
            Public => publicity == Publicity::Public,
        }
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum Publicity {
    Public,
    Private,
}

impl Publicity {
    // If we have a chained import, what
    pub fn pipe(self, other: Publicity) -> Publicity {
        if self == Publicity::Public && other == Publicity::Public {
            Publicity::Public
        } else {
            Publicity::Private
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn insertion() {
        let manager = NamespaceManager::new();

        let root = manager.create_root();
        assert!(!manager.insert_member(root, "member".into(), 2, Publicity::Public));
    }

    #[test]
    fn path() {
        let manager = NamespaceManager::<()>::new();

        let root = manager.create_root();
        let a = manager.create_named_namespace(
            root,
            "a".into(),
            Publicity::Public,
            Some(ExportMode::All),
        );
        let b = manager.create_named_namespace(
            root,
            "b".into(),
            Publicity::Public,
            Some(ExportMode::All),
        );
        let b_child = manager.create_anonymous_namespace(b, Some(ExportMode::All));
        let a_child = manager.create_named_namespace(
            a,
            "a_child".into(),
            Publicity::Public,
            Some(ExportMode::All),
        );
        assert_eq!(manager.get_path(root), "", "root path isn't right");
        assert_eq!(manager.get_path(a), "\\a", "a's path isn't right");
        assert_eq!(manager.get_path(b), "\\b", "b's path isn't right");
        assert_eq!(
            manager.get_path(b_child),
            "\\b\\",
            "b_child's path isn't right"
        );
        assert_eq!(
            manager.get_path(a_child),
            "\\a\\a_child",
            "a_child's path isn't right"
        );
    }

    #[test]
    fn find_obj() {
        let manager = NamespaceManager::<u32>::new();

        let root = manager.create_root();
        let a = manager.create_named_namespace(root, "a".into(), Publicity::Public, Some(ExportMode::All));
        let b = manager.create_named_namespace(root, "b".into(), Publicity::Public, Some(ExportMode::All));

        manager.insert_member(root, "hi".into(), 42, Publicity::Public);

        let found = manager.search(root, "hi".split('\\'));
        assert!(matches!(found, Some(NamespaceContent::Other(42))));
    }
}
